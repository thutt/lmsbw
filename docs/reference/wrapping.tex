% Copyright (c) 2012 Taylor Hutt, Logic Magicians Software
%
% This program is free software: you can redistribute it and/or
% modify it under the terms of the GNU General Public License as
% published by the Free Software Foundation, either version 3 of the
% License, or (at your option) any later version.
%
% This program is distributed in the hope that it will be useful, but
% WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
\chapter{Wrapping Your Build}\label{chap:wrapping}

Determining the best way to wrap your project's build is important to
the maintainability and speed of the build process as a whole.  This
chapter will guide you with some suggestions for setting up and
creating your master configuration, component configurations and the
API requirements of a component \makefile.

We can break this down to the steps which must be taken to wrap your
build:

\begin{description}
\item Defining Roles

  Maintaining a build process for a large system transcends the \bni
  team; managers and developers must also become involved stake
  owners.  Definition, and acceptance, of roles for all players is an
  important part of success.  This will be discussed in
  \xref{wrap:build-process-roles}.

\item Master Configuration

  The master configuration file sets up \lmsbw to load all component
  configurations that are part of the project.  This will be discussed
  in \xref{wrap:master-configuration}.

\item Component Creation

  Deciding how to split your project to create components, and the
  actual component configuration files will have a direct effect on
  the quality of the wrapped build.  Component creation will be
  discussed in \xref{wrap:component-creation}.

\item Component \makefile

  Each \makefile associated with a component must meet the compliance
  requirements of \lmsbw.  This will be discussed in
  \xref{wrap:component-makefile}.

\end{description}

\section{Build Process Roles}\label{wrap:build-process-roles}

\lmsbw provides its greatest benefits when wrapping large projects
consisting of many different sub-projects and possibly many different
product configurations.  The uncertainty that arises about component
configuration from situations like these is understandable; \lmsbw is
a new tool for you.

Here are a few tenets to help guide you to the right configuration
choices:

\begin{description}
  \item High-level Product Configuration

    This job is most well-suited to \emph{product management}.

    The product configuration -- which sub-projects are included into
    each SKU produced by your company -- is a task owned by the
    product management team.

  \item Build Process Configuration

    This aspect is reall an amalgam of roles: the configuration of the
    build process requires the cooperation of the product management
    team (to determine what is included and what is excluded), the
    development team (to create \& maintain a \makefile for their
    sub-project) and the \bni team (to create the actual configuration
    that \lmsbw will use).

  \item Build Process Maintenance

    This job is best subsumed by the \emph{\bni} team.

    The \bni team is not responsible for sub-project \makefile
    maintenance, but they are responsible for the overall
    infrastructure of the build process as a whole.

    They will be responsible for the automated build machines,
    delivery of build output, and to a large part, the overall
    structure and maintenance of the output produced by the build
    process.

  \item Component \makefile Maintenance

    This job is be assigned to the \emph{development} teams
    responsible for the source code.

    Since \lmsbw strictly defines an interface -- an API -- for
    \makefile implementation (\xref{wrap:component-makefile}), it
    easily follows that the developers responsible for a sub-project
    should be responsible for writing a conformant \makefile for that
    sub-project.  After all, they are the ones familiar with the
    interrelationships between the source modules.

    If needed, the \bni team can become involved to help with
    performance or conformance issues.

\end{description}

Cooperation is important in all of this; a build process will only be
successful if everyone pulls their weight and stives for the best
outcome.

\section{Master Configuration}\label{wrap:master-configuration}

Your master configuration file must do the following:

\begin{enumerate}
\item Declare a component loading function.  See
  \xref{variables:load-configuration-function}.
\item Declare the desired \emph{build support}.  See
  \xref{variables:component-build-support}.
\item Provide an implementation for the declared component loading
  function.
\end{enumerate}

Loading component configuration files is straightforward, but as
different operating systems have varying file system capabilities,
your decisions on how to set up your component configuration files
will be affected.  The following sections provide some suggestions,
and some pointers to sample configurations contained in the \lmsbw
distribution.

\subsection{Directory of Configuration Files}\label{wrap:directory}

The basic recommendation for \lmsbw component configuration is to
place all your component configuration files into the same directory,
centralizing maintenance and making global configuration changes much
easier.  The \texttt{load-configuration} function can easily load all
the component configuration files from the common directory.

\subsection{Symlinks to Configuration Files}

With a more complicated project structure, perhaps one with multiple
SKUs and different components in each SKU, you can still keep all your
configuration files in a single directory, but on top of that you will
have \emph{configuration} directories for each distinct product.
These \emph{configuration} directories will be populated with relative
symlinks\footnote{Always use relative symlinks.  Absolute symlinks
  encode full pathname structure into your build system, and that is
  undesirable.} to the original configuration file; see the
\texttt{lite-consumer-pro} sample (\xref{samples:lite-consumer-pro})
for an example of how this is performed.

\subsection{Conditional Component Declaration}

If your operating system does not support symbolic links, you can
export an environment variable from your shell, include all your
component configuration files, as in \xref{wrap:directory}, and use
the facilities of \gnumake to conditionally include only the desired
components.

See the \texttt{sports} sample (\xref{samples:sports})  for an example of this configuration
strategy.

\subsection{Configurations for More Speed}

If you have a project with hundreds of components, and the startup
time for \lmsbw is longer than the incremental build of your part of
the project, you may be able to perform some configuration magic to
regain much of that lost incremental development speed.  Here's how:

\begin{itemize}
\item New Master Configuration

  Create a new master configuration which contains only your component
  and necessary prequisites.

  Because \lmsbw shares build output, the \emph{small} master
  configuration will cause the component to be built in the same
  directory as the \emph{large} master configuration.

\item Incrementally Build

  Once your new master configuration is set up, you can incrementally
  build your component with a much smaller startup time.

  If your component can be tested stand-alone, you can even test using
  this smaller master configuration.

\item Switch Back to \emph{Large} Master Configuration

  Once you have completed your work and verified that the changes to
  your component are satisfactory, switch back to the \emph{large}
  master configuration file, and re-build.

  Since your project is already built, the only work necessary will be
  to quickly install your component into the main configuration's
  install directory.
\end{itemize}

\section{Component Creation}\label{wrap:component-creation}

A component is a set of source files that can be transformed into a
deliverable for a project.  Components must be declared to \lmsbw
through a simple API that has been provided; once declared, \lmsbw
takes care of all the administrative details for building.

One good heuristic for determining how to split a system into
components is to start with the top-level directories that are entered
via \make-recursion with the current build system.  The overall NULL
build times will immediately improve, but if each recursively-invoked
\makefile again invokes \make, the incremental builds can become the
bottleneck.

If incremental builds become a bottleneck, the recommended solution is
to \emph{divide \& conquer}: create first-class components from second
or third level directories in the build process.  Each sub-directory
directly assigned to component will have little impact on the NULL
build time, but will have a great impact on reducing incremental build
times.  It will have a great impact because fewer directories will be
entered to build changed components.

For each declared source component, \lmsbw will generate \makefile
rules that are used to perform the \lmsbw verbs on the component.

The following sections describe how to declare the supported
component types of \lmsbw.

\subsection{\texttt{declare\_source\_component}}

A source component is a set of sources that is directly available in
the project's source tree.

To declare a source component to \lmsbw, the following
information is required:

\begin{enumerate}
\item Component Name

  A name must be provided that will be used to refer to the component
  when using \lmsbwcmd, or as a prerequisite of other components.

  The name supplied must be a valid \makefile variable name.

\item Component Description

  A brief description of the component must must supplied.  This
  description will be shown if the \texttt{components} verb
  (\xref{lmsbw:target:components}) is used to show a list of all the
  components defined in the build project.

\item Reason for building component

  A component is included in a project for one of two reasons:

  \begin{itemize}
    \item It's part of the delivered product
    \item It's used by the build system to help build the delivered
      product.
  \end{itemize}

  If the component is part of the product, the reason is
  \texttt{image}, and if it's part of the build the reason is
  \texttt{build}.  This choice affects which toolchain is used to
  build the component, and where it is installed in the build tree.
  See \xref{variables:reason}.

\item Configuration File

  The full pathname of the configuration file that defines the
  component.  It is included as part of the declaration so that
  changes to the configuration file will force the component to be
  rebuilt.

  Since the pathname may not be known until the configuration file
  itself is loaded, it is the responsibility of the
  \texttt{load-configuration-function}
  (\xref{variables:load-configuration-function}) to marshal this
  information to the component configuration file.

  See the \texttt{sports} (\xref{samples:sports}) sample for one
  approach to addressing this issue.

\item Path to Source Directory

  The full pathname to the directory containing the sources of the
  component is also necessary.  To be flexible and allow any client of
  the wrapped build to put the software in any location on disk, it is
  incumbent upon the developer to determine the full pathname of the
  source directory at configuration load time.  There are many ways to
  accomplish this, here are a few suggestions:

  \begin{itemize}
    \item Use the \gnumake \texttt{realpath} function and a relative path from
      the configuration file.
    \item Use an environment variable to denote the root of the source
      tree, and append the relative path to the component.
  \end{itemize}

\item List of prerequisite components

  If your component requires one or more other components to have been
  built and installed prior to this component being built, you must
  provide that information when declaring a component.  \lmsbw will
  ensure that all prerequisite components are built and installed
  before the dependent components are built.
\end{enumerate}

Once this information has been gathered, it is possible to declare
components using the \texttt{declare\_source\_component} function
(\xref{api:declare-source-component}).  The following are a few
examples of declaring source components:

\begin{itemize}
\item A component used in the build

Figure~\tabref{wrap:simple-component-declaration} declares a component
named \texttt{compiler}, that is included in the project because it is
used as part of the \texttt{build}.  It's configuration file is named
by a \make variable, and the source is relative to a directory named
by the variable \texttt{PROJECT\_SOURCE\_ROOT}.

\begin{figure}
\hrulefill
\begin{verbatim}
$(call declare_source_component,              \
       compiler,                              \
       Compiler for build system,             \
       build,                                 \
       $(CURRENT_CONFIGURATION_FILE),         \
       $(PROJECT_SOURCE_ROOT)/src/compiler)
\end{verbatim}
\hrulefill
\caption{Simple Source Component Declaration}\label{wrap:simple-component-declaration}
\end{figure}

Any other component that \emph{uses} this compiler in the build
process must list the \texttt{compiler} component as a prerequisite.

\item A component with a prerequisite

Figure~\tabref{wrap:prerequisite-component-declaration} declares a
component, named \texttt{consumer}, with a prerequisite called
\texttt{producer}; \texttt{producer} will always be built before
\texttt{consumer}.  It is included in the project because it is
delivered as part of the project \texttt{image}.  It's configuration
file is named by a \make variable.

\begin{figure}
\hrulefill
\begin{verbatim}
$(call declare_source_component,              \
       consumer,                              \
       Consumes data structure & API,         \
       image,                                 \
       $(CURRENT_CONFIGURATION_FILE),         \
       $(subst sample.cfg,src/consumer,$(1)), \
       producer)
\end{verbatim}
\hrulefill
\caption{Source Component with Prerequisite Declaration}\label{wrap:prerequisite-component-declaration}
\end{figure}

An idiom you might see in many component configuration files is the
handling of parameter number five (5) -- the source directory path.
This file containing this code is loaded from the declared
\texttt{load-configuration-function}, and that component
configuration-loading function is passed a single parameter: the full
pathname of the master configuration file itself.

Of course, since the component configuration file is loaded and
evaluated in the context of the \texttt{load-configuration-function},
the full path to the configuration file is still available as
\texttt{\$(1)}\footnote{Provided the configuration file and the source
  directory  are in the same directory tree.}.

\begin{figure}
\hrulefill
\begin{small}
\begin{verbatim}
  .../build-process/samples/source-api:
  drwxrwxr-x  3 users users 4096 Jul 26 20:26 .
  drwxr-xr-x 10 users users 4096 Jul 19 19:07 ..
  -rw-rw-r--  1 users users 1664 Jul 21 20:34 sample.cfg
  drwxrwxr-x  4 users users 4096 Jun 27 05:23 src

  .../build-process/samples/source-api/src:
  drwxrwxr-x 4 users users 4096 Jun 27 05:23 .
  drwxrwxr-x 3 users users 4096 Jul 26 20:26 ..
  drwxrwxr-x 2 users users 4096 Jul 14 19:30 consumer
  drwxrwxr-x 2 users users 4096 Jul 21 20:00 producer
\end{verbatim}
\end{small}
\hrulefill
\caption{Directory Structure}\label{wrap:config-structure}
\end{figure}

Figure \tabref{wrap:config-structure} shows that the idiom in
argument five (5) is correct because the project configuration file
resides in the same directory as the component source directory.  The
code for this parameter replaces the configuration file name -- which
is known -- with the name of the source directory for the component.

\end{itemize}


\subsubsection{Valid Attributes}

The following attributes can be set for source components.

\begin{itemize}
\item{\texttt{component\_attribute\_no\_parallel\_build}}
  (\xref{api:component-attribute-no-parallel-build})
\item{\texttt{component\_attribute\_build\_target}}  (\xref{api:component-attribute-build-target})
\item{\texttt{component\_attribute\_install\_target}} (\xref{api:component-attribute-install-target})
\item{\texttt{component\_attribute\_api}} (\xref{api:component-attribute-api})
\end{itemize}

\section{Component \makefile}\label{wrap:component-makefile}

Each component must have a build process that adheres to the following
rules:

\begin{itemize}
\item \makefile

  Each component declares a directory which contains the source code
  and, implicitly, the build process for it.  The build process must
  be invoked through a \makefile and the \makefile must be present in
  the top-level source directory of the component.

\item Toolchain

  \lmsbw manages the toolchain that is used when building a component,
  and therefore each component's build process should only use the
  standard macros for accessing toolchain tools; for example, use
  \texttt{\$(CC)} rather than \texttt{cc} or \texttt{gcc}.

  The \gnumake reference manual describes all the standard macros that
  are available to access development tools, and
  \xref{toolchain-usage:variables} lists the standard macros provided
  by \lmsbw.

\item Test Execution

  Because \lmsbw facilitates easy cross-compilation to a different
  architecture, no component which is declared to be part of the
  product image (see \xref{variables:reason}) should execute any
  program that is built by the component build\footnote{Unless it is
    known with certainty that the build will never be cross-compiled
    to a different architecture.}.

  You must be very careful when testing in a cross-compiled
  environment; the details of this are beyond the scope of this
  software.

\item \texttt{build} target

  The \makefile must have a target that is invoked to \emph{build} the
  component.  By default, \lmsbw will invoke the component \makefile
  with no target; in other words, the default target of the component
  \makefile is used to build the component.

  The \texttt{component\_attribute\_build\_target} API
  (\xref{api:component-attribute-build-target}) allows you to alter
  the target used to build a individual component.

  \xref{overriding:overriding-build} shows how you can override this
  default behavior.

\item \texttt{install} target

  The \makefile must have a target that is invoked to \emph{install}
  the component.  By default, \lmsbw will invoke the component
  \makefile with the target \texttt{install}.

  The \texttt{install} target must \emph{install} public output of the
  build process into the directory denoted by the \makefile variable
  \texttt{DESTDIR}.  \texttt{DESTDIR} is a standard \make variable
  used when installing software.

  To be compliant, a component's build process should be written to
  assume that the directory into which it installs files is the root
  directory.  For example, if your component, \texttt{alpha}, is
  installing header files, it should be written to do something as
  shown in figure~\tabref{wrap:install-target}.

\begin{figure}
\hrulefill
\begin{verbatim}
$(MKDIR) --parents $(DESTDIR)/usr/include/alpha
$(CP) --recursive                          \
     $(LMSBW_C_BUILD_DIRECTORY)/include/*  \
     $(DESTDIR)/usr/include/alpha
\end{verbatim}
\hrulefill
\caption{Installing from \texttt{install} target}\label{wrap:install-target}
\end{figure}

  \lmsbw guarantees that \texttt{DESTDIR} will be defined.

  The \texttt{component\_attribute\_install\_target} API
  (\xref{api:component-attribute-install-target}) allows you to change
  the target used to build a individual component.

  \xref{overriding:overriding-install} shows how you can override this
  default behavior.

\end{itemize}

\section{\lmsbw-supplied Variables}

\lmsbw provides several variables to the component \makefile.  The
following section describes these variables.

\subsection{\destdir}

The \destdir variable must be used as a root-directory prefix on the
component \emph{install} rules.

\lmsbw creates the directory and sets \destdir to the absolute
pathname.  Your rules may assume the directory exists and that full
control of the directory is available.


\subsection{\texttt{LMSBW\_C\_BUILD\_INSTALL\_DIRECTORY}}\label{wrap:build-install-directory}

You can use this as a prefix to access the build output for components
that have their \texttt{reason} (\xref{variables:reason}) variable set
to \texttt{build}.

See \xref{wrap:using-build-components} for details on using this variable.

\subsection{\texttt{LMSBW\_C\_INSTALL\_DIRECTORY}}

This is the root directory where all components are installed.  You
can use this as the base directory when accessing the API directories
exported by other, prerequisite, components.

\subsection{\texttt{LMSBW\_C\_BUILD\_DIRECTORY}}\label{wrap:lmsbw-c-build-directory}

This is set to the root of the build directory for the associated
component.  The component \makefile can place files such as \mtree
manifests or \make sentinels into this directory.

This is \emph{not} the directory in which the component \makefile is
started.   Do not put object files into this directory.

Compare \xref{wrap:lmsbw-c-build-working-directory}.

\subsection{\texttt{LMSBW\_C\_BUILD\_WORKING\_DIRECTORY}}\label{wrap:lmsbw-c-build-working-directory}

This variable holds the actual directory in which the component's
build will be executed.

Compare \xref{wrap:lmsbw-c-build-directory}.

\subsection{\texttt{CFLAGS}}

This is the union of the global \texttt{CFLAGS} value managed by
\lmsbw and the per-component value set via
\texttt{\texttt{component\_attribute\_cflags}} (\xref{api:cflags}).

The component \makefile should not assign directly to \texttt{CFLAGS},
but instead should append additional options to it.

\subsection{\texttt{GMSL}}

This is the absolute pathname of the directory containing the \gmsl
library.  If you want to use \gmsl in your component's build process,
you need to do the following:

\begin{verbatim}
  include $(GMSL)/gmsl
\end{verbatim}

\section{Using a Prerequisite's API}\label{wrap:using-prerequisite-api}

If your component has listed a prerequisite component, and the
prerequisite component has declared an API, you can access the API
directories by appending the API directory to the value of
\texttt{LMSBW\_C\_INSTALL\_DIRECTORY}.

If, for example, a prerequisite component declared an API at
\texttt{/usr/include/src}, you would be able to access the
include files with:

\begin{verbatim}
CFLAGS  += -I$(LMSBW_C_INSTALL_DIRECTORY)/usr/include/src
\end{verbatim}

\section{Using \texttt{build} Components}\label{wrap:using-build-components}

The \texttt{LMSBW\_C\_BUILD\_INSTALL\_DIRECTORY} variable
(\xref{wrap:build-install-directory}) is passed down to the component
build process, and it can be used to access \texttt{build} component
data.

This is the root of the install directory of components that have
their \texttt{reason} variable set to \texttt{build}
(\xref{variables:reason}).

For example, if your project had a \texttt{build} component named
\texttt{check} that installs binaries in \texttt{/usr/bin/check}, you
could access it from your component's \makefile with the following:

\begin{verbatim}
$(LMSBW_C_BUILD_INSTALL_DIRECTORY)/usr/bin/check
\end{verbatim}
