% Copyright (c) 2012 Taylor Hutt, Logic Magicians Software
%
% This program is free software: you can redistribute it and/or
% modify it under the terms of the GNU General Public License as
% published by the Free Software Foundation, either version 3 of the
% License, or (at your option) any later version.
%
% This program is distributed in the hope that it will be useful, but
% WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
\chapter{Wrapping Your Build}\label{chap:wrapping}

Determining the best way to wrap your project's build is important to
the maintainability and speed of the build process as a whole.  This
chapter will guide you with some suggestions for setting up and
creating your master configuration, component configurations and the
API requirements of a component \makefile.

We can break this down to the steps which must be taken to wrap your
build:

\begin{description}
\item Defining Roles

  Maintaining a build process for a large system is a thankless,
  unwieldy job that transcends the \bni team; managers and developers
  must also become involved and be stake owners in the process.

  Definition, and acceptance, of roles for all players is an important
  part of success.

  This will be discussed in \xref{wrap:build-process-roles}.

\item Master Configuration

  Your master configuration file -- the one which is provided as a
  command line argument of \lmsbw -- sets up \lmsbw with a callback
  that is used to load all component configurations that are part of
  your project.  If you've got a complicated project -- one with
  multiple SKUs, and different sets of components delivered with each
  SKU -- then the loading of the individual component configuration
  files may seem daunting, but it's really very tractable.

  This will be discussed in \xref{wrap:master-configuration}.

\item Component Creation


  Besides the labor of creating the component configurations
  (\xref{wrap:component-creation}) and providing the component
  configurations to \lmsbw (\xref{wrap:master-configuration}), you
  also have to decide how to split your build process into individual
  components.

  One good heuristic is to start with the top-level directories that
  are entered via \make-recursion with your current build system.
  Your overall NULL build times will immediately improve, but if each
  recursively-invoked \makefile again recursively invokes \make, the
  incremental builds can quickly reach the top of the ``it's taking
  too much time'' complaints.

  If this happens, the recommended solution is to \emph{divide \&
    conquer}: create first-class components from second or third level
  directories in the build process.  Each sub-directory directly
  assigned to component will have little impact on the NULL build, but
  will have a great impact on incremental builds.  It will have a
  great impact because fewer directories will be entered to build
  changed components.

  Component creation will be discussed in
  \xref{wrap:component-creation}.

\item Component \makefile

  Each \makefile associated with a component must meet the compliance
  requirements (\xref{wrap:component-makefile}) of \lmsbw.  If a
  \makefile is not fully compliant, the build will probably fail in
  some mysterious way.  It could fail, for example, due to header
  files or executables not being available because the \makefile of
  some component did not properly install them.

  This will be discussed in \xref{wrap:component-makefile}.

\end{description}

\section{Build Process Roles}\label{wrap:build-process-roles}

\lmsbw provides its greatest benefits when wrapping large projects
consisting of many different sub-projects and possibly many different
product configurations.  The uncertainty that arises about component
configuration from situations like these is understandable; \lmsbw is
a new tool for you.

Here are a few tenets to help guide you to the right configuration
choices:

\begin{itemize}
  \item Component \makefile maintenance is for the \emph{development} teams.

    Since \lmsbw strictly defines an interface -- an API -- for
    \makefile implementation, it easily follows that the developers
    responsible for a sub-project should be responsible for writing a
    conformant \makefile for that sub-project.  After all, they are
    the ones familiar with the interrelationships between the source
    modules.

    If needed, the \bni team can become involved to help with
    performance or conformance issues.

  \item Overall build \emph{process} maintenance is for the
    \emph{\bni} team.

    The \bni team is not responsible for sub-project \makefile
    maintenance, but they are responsible for the overall
    infrastructure of the build process as a whole.

    They will be responsible for the automated build machines,
    delivery of build output, and to a large part, the overall
    structure and maintenance of the output produced by the build
    process.

  \item High-level product configuration is for \emph{product
    management}.

    The product configuration -- which sub-projects are included into
    each SKU produced by your company -- is a task owned by the
    product management team.

  \item Build process configuration is an amalgam of roles

    The configuration of the build process requires the cooperation of
    the product management team (to determine what is included and
    what is excluded), the development team (to create \& maintain a
    \makefile for their sub-project) and the \bni team (to create the
    actual configuration that \lmsbw will use).
\end{itemize}

Cooperation is important in all of this; no one likes change,
especially when the final results are nebulous until everything is
finalized and working.

\section{Master Configuration}\label{wrap:master-configuration}

Your master configuration file must do the following:

\begin{enumerate}
\item Declare a component loading function.  See
  \xref{variables:load-configuration-function}.
\item Declare the desired \emph{build support}.  See
  \xref{variables:component-build-support}.
\item Provide an implementation for the declared component loading
  function.
\end{enumerate}

Loading component configuration files seems fairly straightforward,
but because different operating systems have varying file system
capabilities, your decisions on how to set up your component
configuration files will be affected.  The following sections provide
some suggestions, and some pointers to sample configurations contained
in the \lmsbw distribution.

\subsection{Directory of Configuration Files}\label{wrap:directory}

The basic recommendation for \lmsbw component configuration is to
place all your configuration files into the same directory.  This
centralizes all the maintenance and makes global configuration changes
much easier.  Your \texttt{load-configuration} function can simply
load all the component configuration files from the common directory.

This works well for a single SKU, but falls apart quickly if you have
multiple.

\subsection{Symlinks to Configuration Files}

With a more complicated project structure, perhaps one with multiple
SKUs and different components in each SKU, you can still keep all your
configuration files in a single directory, but on top of that you will
have \emph{configuration} directories for each distinct product.
These \emph{configuration} directories will be populated with relative
symlinks to the original configuration file; see the
\texttt{lite-consumer-pro} sample for an example of how this is
performed.

\subsection{Conditional Component Declaration}

If your operating system does not support symbolic links, you can
export an environment variable from your shell, include all your
component configuration files, as in \xref{wrap:directory}, and use
the facilities of \gnumake to conditionally include only the desired
components.

See the \texttt{sports} sample for an example of this configuration
strategy.

\subsection{Configurations for More Speed}

If you have a project with hundreds of components, and the startup
time for \lmsbw is longer than the incremental build of your part of
the project, you may be able to perform some configuration magic to
regain much of that lost incremental development speed.  Here's how:

\begin{enumerate}
\item New master configuration

  Create a new global configuration which contains only your component
  and components necessary to build your component.

  Because \lmsbw shares build output, the \emph{small} master
  configuration will cause the component to be built in the same
  directory as the \emph{large} master configuration.

\item Incrementally Build

  Once set up, you can incrementally build your component with a much
  smaller startup time.

  If your component can be tested stand-alone, you can even test using
  this smaller master configuration.

\item Switch Back to \emph{Large} Master Configuration

  Once you have completed your work and verified that the changes to
  your component are satisfactory, switch back to the \emph{large}
  master configuration file, and re-build.

  Since your project is already built, it will be quickly installed
  into the new configuration's install directory.

\end{enumerate}

\section{Component Creation}\label{wrap:component-creation}

A component is a set of source files that can be transformed into a
deliverable for your project.  You must declare components to \lmsbw
through a simple API that has been provided; once declared, \lmsbw
takes care of all the administrative details for building.

For each declared source component, \lmsbw will generate target
\makefile rules that are used to perform the \lmsbw verbs on the
component.

The following sections describe how to declare the supported
component types of \lmsbw.

\subsection{\texttt{declare\_source\_component}}

A source component is a set of sources that is directly available in
your project's source tree.

To declare a source component to \lmsbw, you'll need the following
information:

\begin{enumerate}
\item Component Name

  You must provide a name that will be used to reference the component
  on the \lmsbw command line, and as a prerequisite of other
  components.

  The name supplied must be a valid \makefile variable name.

\item Component Description

  You must supply a brief description of the component.  This
  description will be shown if the \texttt{components} verb
  (\xref{lmsbw:target:components}) is used to show a list of all the
  components defined in the build project.

\item Reason for building component

  A component is included in a project for one of two reasons:

  \begin{itemize}
    \item It's part of the delivered product
    \item It's used by the build system to help build the delivered
      product.
  \end{itemize}

  If the component is part of the product, the reason is
  \texttt{image}, and if it's part of the build the reason is
  \texttt{build}.

  This choice affects which toolchain is used to build the component,
  and where it is installed in the build tree.  See \xref{variables:reason}.

\item Configuration File

  The full pathname of the configuration file that defines the
  component.  It is part of the declaration so that changes to the
  configuration file will force the component to be rebuilt.

  Since the pathname may not be known until the configuration file
  itself is loaded, it becomes the responsibility of your
  \texttt{load-configuration-function}
  (\xref{variables:load-configuration-function}) to marshal this
  information to the component configuration file.  See the
  \texttt{sports} (\xref{samples:sports}) sample for one approach to
  addressing this issue.

\item Path to Source Directory

  The full pathname to the directory containing the sources of the
  component is also necessary.  To be flexible and allow any client of
  your wrapped build to put the software in any location on disk, it
  is incumbent upon you to determine the full pathname of the source
  directory at configuration load time.  There are many ways to
  accomplish this, here are a few suggestions:

  \begin{itemize}
    \item Use the \gnumake \texttt{realpath} function and a relative path from
      the configuration file.
    \item Use an environment variable to denote the root of the source
      tree, and append the relative path to the component.
  \end{itemize}

\item List of prerequisite components

  If your component requires one or more other components to have been
  built and installed prior to this component being built, you must
  provide that information when declaring your component.  \lmsbw will
  ensure that all prerequisite components are built and installed
  before the dependent components are built.
\end{enumerate}

Once this information has been gathered, you can create a component
configuration file and declare your component with the
\texttt{declare\_source\_component} function.  The following are a few
examples of declaring source components:

\begin{itemize}
\item A component used in the build

The following declares a component named \texttt{compiler}, which is
included in the project because it is used as part of the
\texttt{build}.  It's configuration file is named by a \make variable,
and the source is relative to a directory named by the variable
\texttt{PROJECT\_SOURCE\_ROOT}.

\begin{verbatim}
$(call declare_source_component,              \
       compiler,                              \
       Compiler for build system,             \
       build,                                 \
       $(CURRENT_CONFIGURATION_FILE),         \
       $(PROJECT_SOURCE_ROOT)/src/compiler)
\end{verbatim}

Any other component that \emph{uses} this compiler must list the
\texttt{compiler} component as a prerequisite.

\item A component with a prerequisite

The following declares a component, named \texttt{consumer}, with a
prerequisite called \texttt{producer}; \texttt{producer} will always
be built before \texttt{consumer}.  It is included in the project
because it is delivered as part of the project \texttt{image}.  It's
configuration file is named by a \make variable.

\begin{verbatim}
$(call declare_source_component,              \
       consumer,                              \
       Consumes data structure & API,         \
       image,                                 \
       $(CURRENT_CONFIGURATION_FILE),         \
       $(subst sample.cfg,src/consumer,$(1)), \
       producer)
\end{verbatim}

An idiom you might see in many component configuration files is the
handling of parameter number five (5) -- the source directory path.
This file containing this code is loaded from the declared
\texttt{load-configuration-function}, and that component
configuration-loading function is passed a single parameter: the full
pathname of the master configuration file itself.

Of course, since the component configuration file is loaded and
evaluated in the context of the \texttt{load-configuration-function},
the full path to the configuration file is still available as
\texttt{\$(1)} -- provided they are in the same directory tree.

The idiom in argument five (5) is correct because the project
configuration file resides in the same directory as the component
source directory.  The code for this parameter replaces the
configuration file name -- which is known -- with the name of the
source directory for the component.\todo{Show the tree structure}

\end{itemize}


\subsubsection{Valid Attributes}

The following attributes can be set for source components.

\begin{itemize}
\item{\texttt{component\_attribute\_no\_parallel\_build}}
  (\xref{api:component-attribute-no-parallel-build})
\item{\texttt{component\_attribute\_build\_target}}  (\xref{api:component-attribute-build-target})
\item{\texttt{component\_attribute\_install\_target}} (\xref{api:component-attribute-install-target})
\item{\texttt{component\_attribute\_api}} (\xref{api:component-attribute-api})
\end{itemize}

\section{Component \makefile}\label{wrap:component-makefile}

Each component must have a build process that adheres to the following
rules:

\begin{itemize}
\item \makefile

  Each component declares a directory which contains the source code
  and, implicitly, the build process for it.  The build process must
  be invoked through a \makefile and the \makefile must be present in
  the top-level source directory of the component.

\item Toolchain

  \lmsbw manages the toolchain that is used when building a component,
  and therefore each component's build process should only use the
  standard macros for accessing toolchain tools; for example, use
  \texttt{\$(CC)} rather than \texttt{cc} or \texttt{gcc}.

  The \gnumake reference manual describes all the standard macros that
  are available to access development tools.

  In other words, a compliant \makefile should not directly reference
  programs, such as the C compiler with \texttt{cc}, or the linker
  with \texttt{ld}.  Rather, the compliant \makefile should use macros
  such as \texttt{\$(CC)} and \texttt{\$(LD)} respectively.

\item Test Execution

  Because \lmsbw facilitates easy cross-compilation to a different
  architecture, no component which is declared to be part of the
  product image (see \xref{variables:reason}) should execute any
  program that is built by the component build.

  If your system is never meant to cross compile, then it's ok for the
  component build process to execute tests; if cross compilation is
  later used, the tests will have a different architecture type and
  fail to run.

  You must be very careful when testing in a cross-compiled
  environment; the details of this are beyond the scope of this
  software.

\item \texttt{build} target

  The \makefile must have a target that is invoked to \emph{build} the
  component.  By default, \lmsbw will invoke the component \makefile
  with no target; in other words, the default target of the component
  \makefile is used to build the component.

  The \texttt{component\_attribute\_build\_target} API
  (\xref{api:component-attribute-build-target}) allows you to change
  the target used to build a individual component.

  \xref{overriding:overriding-build} shows how you can override this
  default behavior.

\item \texttt{install} target

  The \makefile must have a target that is invoked to \emph{install}
  the component.  By default, \lmsbw will invoke the component
  \makefile with the target \texttt{install}.

  The \texttt{install} target must \emph{install} public output of the
  build process into the directory denoted by the \makefile variable
  \texttt{DESTDIR}.  \texttt{DESTDIR} is a standard \make variable
  used when installing software.

  To be compliant, a component's build process should be written to
  assume that the directory into which it installs files is the root
  directory.  For example, if your component, \texttt{alpha}, is
  installing header files, it should be written to do something like
  this:

\begin{verbatim}
$(MKDIR) --parents $(DESTDIR)/usr/include/alpha
$(CP) --recursive                          \
     $(LMSBW_C_BUILD_DIRECTORY)/include/*  \
     $(DESTDIR)/usr/include/alpha
\end{verbatim}

  \lmsbw guarantees that \texttt{DESTDIR} will be defined.

  The \texttt{component\_attribute\_install\_target} API
  (\xref{api:component-attribute-install-target}) allows you to change
  the target used to build a individual component.

  \xref{overriding:overriding-install} shows how you can override this
  default behavior.

\end{itemize}

\subsection{\lmsbw-supplied Variables}

\lmsbw provides several variables to the component \makefile.  The
following section describes these variables.

\subsubsection{\destdir}

The \destdir variable must be used as a root-directory prefix on the
component \emph{install} rules.

\lmsbw creates the directory and sets \destdir to the absolute
pathname.  Your rules may assume the directory exists and that full
control of the directory is available.


\subsubsection{\texttt{LMSBW\_C\_BUILD\_INSTALL\_DIRECTORY}}\label{wrap:build-install-directory}

You can use this as a prefix to access the build output for components
that have their \texttt{reason} (\xref{variables:reason}) variable set
to \texttt{build}.

See \xref{wrap:using-build-components} for details on using this variable.

\subsubsection{\texttt{LMSBW\_C\_INSTALL\_DIRECTORY}}

This is the root directory where all components are installed.  You
can use this as the base directory when accessing the API directories
exported by other, prerequisite, components.

\subsubsection{\texttt{LMSBW\_C\_BUILD\_DIRECTORY}}

This is set to the root of the build directory for the associated
component.  The component \makefile can place files such a \mtree
manifests or \make sentinels into this directory.

This is \emph{not} the directory in which the component \makefile is
started, although that directory will be a subdirectory of this one;
do not put object files into this directory.

\subsubsection{\texttt{CFLAGS}}

This is the union of the global \texttt{CFLAGS} value managed by
\lmsbw and the per-component value set via
\texttt{\texttt{component\_attribute\_cflags}} (\xref{api:cflags}).

The component \makefile should not assign directly to \texttt{CFLAGS},
but instead should append additional options to it.

\subsubsection{\texttt{GMSL}}

This is the absolute pathname of the directory containing the \gmsl
library.  If you want to use \gmsl in your component's build process,
you need to do the following:

\begin{verbatim}
  include $(GMSL)/gmsl
\end{verbatim}

\section{Using a Prerequisite's API}\label{wrap:using-prerequisite-api}

If your component has listed a prerequisite component, and the
prerequisite component has declared an API, you can access the API
directories by appending the API directory to the value of
\texttt{LMSBW\_C\_INSTALL\_DIRECTORY}.

If, for example, a prerequisite component declared an API at
\texttt{/usr/include/src}, you would be able to access the
include files with:

\begin{verbatim}
CFLAGS  += -I$(LMSBW_C_INSTALL_DIRECTORY)/usr/include/src
\end{verbatim}

\section{Using \texttt{build} Components}\label{wrap:using-build-components}

The \texttt{LMSBW\_C\_BUILD\_INSTALL\_DIRECTORY} variable
(\xref{wrap:build-install-directory}) is passed down to the component
build process, and it can be used to access \texttt{build} component
data.

This is the root of the install directory of components that have
their \texttt{reason} variable set to \texttt{build}
(\xref{variables:reason}).

For example, if your project had a \texttt{build} component named
\texttt{check} that installs binaries in \texttt{/usr/bin/check}, you
could access it from your component's \makefile with the following:

\begin{verbatim}
$(LMSBW_C_BUILD_INSTALL_DIRECTORY)/usr/bin/check
\end{verbatim}
