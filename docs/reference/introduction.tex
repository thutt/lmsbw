% Copyright (c) 2012 Taylor Hutt, Logic Magicians Software
%
% This program is free software: you can redistribute it and/or
% modify it under the terms of the GNU General Public License as
% published by the Free Software Foundation, either version 3 of the
% License, or (at your option) any later version.
%
% This program is distributed in the hope that it will be useful, but
% WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
\chapter{Introduction}

Recursive use of \make has fallen out of favor since the publication
of \emph{Recursive Make Considered Harmful}
(\texttt{http://aegis.sourceforge.net/auug97.pdf}), but in real-world
situations, recursive \make is still dominant because \make provides
little support towards actually creating a maintainable non-recursive
build system.  The biggest stumbling block to implementing a
non-recursive build system using \make is the complete lack of
scoping; symbol scoping is accomplished by traditional recursive use
of \make, and is all but non-existent in a non-recursive
implementation.  The lack of scoping quickly becomes a maintenance
issue because the \makefile developers must be careful to avoid macro,
target and implicit rule collisions.

Rather than trying to change the world by convincing people to
increase the complexity of their build system with non-recursive use
of \make, the software described in this document aims to simplify the
world by implementing a wrapper system -- implemented entirely in
\gnumake and \texttt{bash} scripts -- which allows you to continue to
use a recursive \make system, but provides you with dramatic
performance improvements by only recursing when something in the
source tree has changed and without requiring you to make widespread
changes to your existing build process.

The following tenets guided the implementation of \lmsbw:

\begin{itemize}
\item Incremental Builds

  \lmsbw was developed with a team of developers in mind, and from that
  perspective the day of a developer involves many small changes and
  rebuilds of the software.  The key focus of \lmsbw is to ensure that
  incremental builds are as fast as possible.

  To achieve such speed, in simple terms, \lmsbw will never recurse
  into a sub-directory unless something in the corresponding source
  tree has changed.  This is accomplished by using the \mtree utility.
  \todo{describe what mtree is.}

\item Disk Space

  Disk space is free relative to the cost of a developer: the amount
  of time wasted by developers performing administrative tasks around
  their build and build output can be a gigantic productivity sink.

  \lmsbw saves time by compromising on space.  Because developers
  rarely need to know where their intermediate build output resides --
  a report is provided which shows where all files are placed, if you
  \emph{need to know} -- \lmsbw will place build output into
  directories based on many global options.  For example, \lmsbw could
  be configured to include the revision control system's branch name
  when determining the build output directories; this means that
  builds, regardless the revision control branch being used, would
  always be incremental.  This is true because switching to an
  already-used branch will use the already-created build directories.

  Trading off increased disk space for improved developer productivity
  makes perfect sense to reduce product development cost.

\item Source Is Immutable

  \lmsbw is a general wrapper for build systems, and generally
  speaking, each build system perform differently: some write all
  output data into the source directory, while others write to a
  user-specified build directory.

  Partially due to the unknown behavior of wrapped builds, \lmsbw has
  been designed to consider the source directory tree to be immutable.
  Further, to reduce the complexity of the implementation of \lmsbw,
  as well as to guarantee correctness, \lmsbw has been written to
  clone the original source directory into the build directory.

  The upshot of this is that the original source directory will never
  be sullied by \lmsbw, nor your own wrapped build process.  Another
  benefit of having an immutable source tree is that you can easily
  use different toolchains -- perhaps for cross compiling to another
  operating system or architecture -- without having to retool your
  own build process.

  \begin{quotation}
    Although \lmsbw considers the source directory immutable, and
    clones it into the build directory, you must not edit your sources
    while the build is in progress.

    The reason for this is that upon a successful build of a
    component, \lmsbw uses \mtree to take a snapshot of the state of
    the source tree; and on later builds uses this snapshot to
    determine if the source tree has changed.  If you edit the source
    tree while the component is building -- after the source tree has
    been cloned into the build tree -- the snapshot of the source tree
    will reflect your editing, and will \emph{not} be consistent with
    the sources that were just built.

    You would not expect to edit your source files while your source
    is compiling with a regular build system; don't do it when using
    \lmsbw either.
  \end{quotation}

\item Uniform Interface

  \lmsbw has been designed to make it easy to wrap an existing build
  process.  In concept, you will declare each one of your
  \emph{components}, usually a source directory containing a
  \makefile, to \lmsbw.  Declaration includes information about the
  directory and options for building it, including which other
  components are prerequisites.

  \lmsbw compiles this information and generates, on-the-fly, a set of
  \make rules and targets which allow your wrapped build process to be
  executed.

  Included in this is a uniform interface: if you want to produce a
  build report for all components, you simply execute \texttt{lmsbw
    report}, but if you want to specifically get a report on the
  \emph{dailyprocessing} component, you would execute \texttt{lmsbw
    report.dailyprocessing}.

  Similarly, many other \emph{verbs} (\xref{lmsbw:target:verbs}) which
  are exported by \lmsbw can be executed globally or on an individual
  component.

  With the designed-in extensibility of \lmsbw, it's also quite simple
  to add your own verbs to the build process.

\item Extensible

  \lmsbw may not have all the features you need, but it uses the
  \emph{Gnu Make Standard Library} (gmsl), it's fully documented and
  it's easy to add new features.

\end{itemize}

\section{Will \lmsbw Benefit You?}

At this point you may be interested, but you're reticent to invest a
lot of time just to find out if \lmsbw will benefit your build.
Fortunately, there is a way to quickly determine if \lmsbw will
provide a benefit, because this source package has a handy script
which will provide you with benchmark numbers.  Just follow these
instructions:

\begin{enumerate}
\item Download \& extract \lmsbw sources

  Download and extract the sources.  We'll use an environment variable
  to note the location.

\begin{verbatim}
cd <directory where you extracted lmsbw>
ld=$(pwd)
\end{verbatim}
\item Build mtree utility
\begin{verbatim}
${ld}/scripts/lmsbw                                          \
   --configuration ${ld}/samples/hello-world/hello-world.cfg \
   --build-root /tmp/lmsbw-test  -- mtree
\end{verbatim}

The command above will output a message indicating where the \mtree
utility was placed; we'll use that in the next command.

\item Test Speed

  The following command will execute the \mtree utility on each
  directory named on the command line, and then output the elapsed
  time for processing all the directories.

\begin{verbatim}
  ${ld}/scripts/lmsbw-mtree-speed-test         \
     --mtree <full path output by step above>  \
     <source directory>...
\end{verbatim}

This is a rough estimate of what your \nullbuild time should be.  To
get a representative rough idea of how long a normal \nullbuild will
take for your project, you should run this command multiple times to
ensure that the in-RAM disk caches are filled.

\end{enumerate}

In short, the \mtree utility performs a \texttt{stat} on every file in
the named directories and produces output which can be used later to
determine if any file in the directory tree has changed.  By knowing
that no files have changed in a source directory, \lmsbw will never
recurse into that directory to build -- modulo other dependency issues
which can force a re-build.\todo{This paragraph should be placed where
  mtree is first mentioned.}

What this means, for you, is that the elapsed time shown is a very
good approximation for how long a full \nullbuild for your project
will take.  Developers performing incremental builds will greatly
benefit by never recursively building source directories that have not
changed.

\todo{What about startup time?}

\section{How \lmsbw Works}

\lmsbw is not a system that actually builds your software; rather, it
is a wrapper for your own build system that, in most cases, will
improve the performance of your build system.  You're probably
wondering how adding a layer on top of an existing build system will
improve the original -- the simple answer is that many build processes
perform altogether too much work when no work needs to be performed,
and \lmsbw cuts out this unnecessary work by never invoking the build
process when nothing has changed since the last build.

Let's examine the what makes \lmsbw different:

\begin{description}
\item Defined Build Process API

  To facilitate rebuilding dependent components when necessary --
  especially when the exported API of a prerequisite component changes
  -- \lmsbw defines an API that wrapped builds must follow.  This API
  requires that each component install its public build product into a
  \texttt{DESTDIR}\todo{Glossary destdir} directory.

\item Component Declarations

  \lmsbw automatically generates rules that are used by \make to build
  your product, but to be able to generate these rules you must
  declare every component that is in your project.

  Once declared, \lmsbw takes control of all aspects of each
  component's build: the build directory, the \texttt{DESTDIR}, the
  install directory, and the toolchain to use.  When your component's
  build process is invoked, it only needs to focus on producing a
  build, and, when requested, installing it into the \texttt{DESTDIR}
  directory.

\item Recurse only when needed

  \lmsbw only maintains the inter-component dependencies that are
  explicitly defined your component declarations.

  Intra-component file dependencies are entirely handled by each
  component's build process.  Not handling file dependencies reduces
  memory use and makes the criteria for recursing easier to determine.

  The general determination for building components is this:

  \begin{itemize}
  \item If the component is not built
  \item If \emph{any} file has been changed in the source tree
  \item If \emph{any} file in a prerequisite's declared API has
    changed
  \item If the component's configuration file has changed
  \end{itemize}

  Any of the above conditions being true causes \lmsbw to recurse into
  the component's build process.  Conversely, if \emph{all} of the
  conditions are false, then \lmsbw will \emph{not} recurse into the
  component's build process; not recursing for components that are
  already built saves an amount of time that is proportional to the
  number and complexity of \make rules present in that directory.

\item Share Build Output

  If your project contains different SKUs, and those SKUs share
  components, \lmsbw is able to share the build output from one SKU
  with another, if the components are compiled exactly the same.

\end{description}

\lmsbw is a lightweight system that has been designed for speeding up
incremental builds.  It handily achieves that goal by performing as
little work as possible from run-to-run.

\section{Steps To Wrap Your Build}

The work needed to wrap your build with \lmsbw is directly
proportional to the size of your build process; a small project will
obviously take less time than a large project, but in both cases the
steps are the same.

\subsection{Configuration File}

You must provide a master configuration file to \lmsbw for your
project.  The main purpose of the configuration file is to create and
set up the \lmsbwconfiguration (\xref{variables:lmsbw-configuration})
variable.

Primarily, you must declare a \gnumake function that will load your
component configuration (\xref{aa:load-configuration-function}), and
you must indicate what \emph{kind} (\xref{variables:kind}) of
components your project will use
(\xref{variables:component-build-support}).

Other fields of \lmsbwconfiguration can be optionally set to further
control the behavior of \lmsbw.

\subsection{Loading Component Configuration}

After loading the command-line-specified master configuration file,
\lmsbw will invoke the component configuration loading function
(\xref{aa:load-configuration-function}).  This function is responsible
for defining all the components that are to be included in your
project.  Generally there is a one-to-one correspondence of components
to component configuration files, that you provide.  The called
function will load each of these files using the \gnumake
\texttt{\$(include)} directive.

The component configuration files are, in fact, \makefile snippets
which can actually have rules that will override the default behavior
of \lmsbw.  See \xref{chap:overriding} for more details on overriding
the default behavior of component building, and there are several
samples included with \lmsbw that show how rule overriding can be
done.

This configuration-loading function must ultimately produce two sets
of data:

\begin{itemize}
\item \lmsbwcomponents

  This is a standard \gnumake variable that is a list of all the
  component names which are to be built.

\item \lmsbwcomponent{<component-name>}

  Each component loaded is assigned a \gmsl\todo{glossary} associative
  array to hold all the data relevant to building the software.

  The keys that are defined for the component's associative array are
  dependent upon the \emph{kind} (\xref{variables:kind}) of the
  component.  For example, a \emph{source} component will define a set
  of keys which would include information such as the source
  directory.  A \emph{download} component would have different keys,
  such as the \texttt{URL} from which the component can be downloaded.

  This flexibility allows new component types to be created without
  affecting existing component types.  See \xref{chap:extending} for
  details on extending \lmsbw.
\end{itemize}


\subsection{\lmsbwcomponent{<component-name>} Configuration}

Each component's associative array contains various bits of
user-provided data which enables \lmsbw to build and install it.

Such user-provided data, for a \emph{source} component, includes:

\begin{itemize}
\item source directory
\item prerequisite components
\item brief description
\item reason for building
  \begin{itemize}
  \item built to be delivered in the product
  \item built to be used in the build
  \end{itemize}
\end{itemize}

Conveniently, there are \lmsbw functions, such as
\texttt{declare\_source\_component}
(\xref{api:declare-source-component}), which simplify the
configuration of components.

\subsection{Recursively Invoking \make}

During the execution of the build process, \lmsbw recursively runs
three different \makefile processes:

\begin{itemize}
\item \lmsbw \makefile

  The first is the main \lmsbw \makefile which handles all the
  configuration and inter-dependencies between components.

\item Component Trampoline \makefile

  The second is a subservient \makefile, yet still part of \lmsbw,
  which performs component-specific configuration such as configuring
  standard \makefile macros (\texttt{CC}, \texttt{LD}, etc.) that
  correspond to the toolchain (\xref{chap:toolchain-usage}) which will
  be used to actually build the component.

  It also ensures that each component's build process is completely
  disjoint from other components; the settings for \emph{component $\alpha$}
  cannot interfere with the settings for \emph{component $\beta$}.

\item Component \makefile

  Finally, the \makefile of the component is executed.  This will
  likely already exist if you are wrapping an existing build process.

  This \makefile will be entered at most twice for each build.  The
  first invocation will be to \emph{build} the component, and the
  second time will be to \emph{install} the component into the
  \destdir.
\end{itemize}
